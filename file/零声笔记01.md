希尔排序：(代码和思想)：

有一个增量gap，初始为长度的一半，且不断减半

每次都以第一个值为增量的下标 i 为开始到结尾

不断将第i个元素插入到  j =  i - n*gap 的正确位置上，保证这个从i往前的间隔为gap的序列有序。

```c
int shell_sort(int *data, int length) {
	int gap = 0; //分组的跨度
	int i = 0, j = 0;

	for (gap = length / 2; gap >= 1;gap /= 2) { // 分组的次数
    	for(i = gap; i < length; i ++) { // 每组遍历 
        	int temp = data[i];
        	for (j = i - gap; j >= 0 && temp < data[j];j = j - gap) { //组内排序
            	data[j+gap] = data[j];
        	}
        	data[j+gap] = temp;
    	}
	}
	return 0;
}
```

后续我觉得可以补充一下桶排序和基数排序，也是比较冷门



KMP算法：

我还是觉得东哥的动态规划状态机思路写代码会更好，贴当时写的代码即可



红黑树：key-value，中序遍历后是一个有序序列（红黑树本身就是BST的一种）

几个应用：

- socket和客户端id
- 内存管理，malloc的数据块可以用红黑树来存，free的时候使用红黑树来查找释放（存疑？有指针p话不应该能直接free吗，除非还有一些其他信息的映射，比如数据块大小，优先级等等，根据这些信息来找p）
- 进程调度，比如将等待时间用红黑树来组织，通过中序遍历可以有序查找（存疑？不应该用队列吗，说实话，不用查找就没必要用红黑树了吧）（应用：linux进程调度CFS）
- Nginx Timer事件管理
- Epoll事件管理



key和value的存放位置，可以把key和value都放在一个node里，但是如果类中数据成员太冗余话会导致算法和业务混合在一起，没有做分离：

- 将left，right单独抽离出来作为一个数据结构rb_entry，而客户将该结构复合进自己的类比如rbtree_node，同时附带该key和对应的的data即可。
- data不要用void*,会额外多了用指针查找的消耗，直接放在rbtree_node即可。
- 为什么key和value都在rbtree_node里，依然不像是算分和业务分离？：其实一个node可以包含多个entry，比如一个coroutine有就绪，等待，休眠几个状态，对应了几颗红黑树，这样数据可以只有一份，但是其数据结构存在于三棵树中。



定义：

- 每个节点是红的或者黑的
- 根节点是黑的
- 叶子结点是黑的
- 如果一个节点是红的，其孩子都是黑的
- 对每个节点，从该节点到其子孙节点的所有路径上包含相同数量的黑色节点





![image-20220615171207809](C:\Users\37412\AppData\Roaming\Typora\typora-user-images\image-20220615171207809.png)

需要记一下此时的status和对应的旋转

左旋：x在y左边，以x为中心旋转，变成y的左节点

右旋，y在x右边，以y为中心旋转，变成x的右节点



插入：

首先根据插入节点的key大小和红黑树的节点的key比大小，利用双指针prev和cur，找到合适的插入位置

记得判断插入位置是否是root(也就是目前红黑树没有节点)

判断最后的插入位置是prev的左子树还是右子树，利用prev进行插入

最后如果prev和newnode都是红色（双红），从newnode开始fixtree

假设newnode的父亲是左枝，（右枝的情况反着写即可）

若其伯父是红色，将父亲和伯父都变黑，祖父变红，更新newnode为祖父继续向上回溯

若其伯父是黑色，还要多一层判断，当前newnode是否是是右孩子

如果newnode是右孩子，则将newnode=parent，同时左旋newnode，这样newnode就变成左孩子了

如果newnode是左孩子，则将其父亲变黑，祖父变红，右旋祖父，即可，不用更新newnode。



找后继：

如果该节点有右孩子，则后继为右孩子的最小值

如果没有右孩子，那么从当前节点开始往上回溯，直到cur是parent的左孩子，则parent就是后继



删除:

首先根据key找到要删除位置的指针，

以该指针为基点，做一个判断，如果该节点只有一边的枝条或者两边都没有，则待会的删除元素就是自己。

如果该节点左右枝条都有，找其直接后继（右孩子的最小节点），作为待删除节点delete。

找到delete的孩子，delete不可能同时有左右孩子，所以找到其左孩子或者右孩子，或者都没有则是nil

如果delete是root的话，需要更新其孩子为root

将delete的孩子接在delete的父亲对应的左右枝条上

将delete的数据覆盖到本该删除的节点之上

判断delete的颜色，如果是黑色，就从其孩子son（注意不是delete）开始fixtree

while循环的条件是son!=root&&son == black

还是假设son是左枝的情况，（右枝的情况反着写）

如果其兄弟是红色，则将其兄弟变黑，父亲变红, 左旋父亲，更新兄弟为son父亲的新的右枝

如果兄弟是黑色，判断其孩子

如果孩子左黑右黑，则兄弟变红，son更新为父亲继续判断。

如果孩子左红右黑，则兄弟变黑，左孩子变红，右旋兄弟，更新兄弟为son父亲的新的右枝

如果孩子左黑右红，则兄弟颜色变为父亲颜色，父亲颜色变黑，兄弟右孩子变黑，左旋父亲

将son直接更新为root退出循环

while循环结束后，更新son颜色为black



磁盘虽然能持久储存数据，但是不能像内存一样随机访问，慢在寻址

假设红黑树在磁盘上，每次都不能通过指针直接获得数据，而是需要磁头不断重新寻址，寻址次数和树的高度相关

所以磁盘上查找若想要提高速度，可以降低红黑树的高度，将二叉树转为多叉树 



M阶b-树定义：（M建议为偶数，这样key的num=M-1为奇数，比较好分裂）

- 每个节点至多有M颗子树
- 根节点至少有两棵子树  
-  除了根节点，其它每个分支节点至少有M/2颗子树
- 所有叶子结点都在同一层
- 有k颗子树的分支节点则存在k-1个key，key按递增顺序进行排序
- key数量n满足:  ceil(M/2)-1<=n<=M-1



btree_node: 

vector<keytype>存keys；

vector<btree_node*>children；数组存了孩子节点的指针，

bool isleaf；是否是叶子节点



btree:{

​	btree_node* root;

​	int M;

}

void insert(key):

插入的时候，先判断当前根节点，根节点满了，那么需要新建一个根节点，并把当前root作为其第一个孩子。

将root右分裂，则孩子中间上浮，新根节点也有了元素，如果根节点没满，就统一调用没满的插入insert_non_full



insert_non_full(node,key):

注意插入的节点只会把key插入到某个叶子节点中，所以递归就好，在递归中就要判断即将插入的新节点node是否满，满则分裂

保证node递归到叶子节点时其中的key一定是未满的

分两种情况：

当前node非叶子结点      

寻找key列表，得到下标index

通过index得到孩子节点，判断孩子节点是否满了

如果节点满了，分裂一个新的孩子节点存右半部分，中间节点上浮到node，更新node keys和children

上浮完后，让key在新的keys里找到插入位置new index

根据newindex得到newnode = children[newindex]

递归调用newnode



删除：查找
- 借位：当中间节点id==ceil（M/2）-1：
	-  从id-1借位：如果id-1>ceil M/2 -1
	
	-  从id+1借位: 如果 id+1>ceil M/2 -1
	
- 合并：当中间节点id>ceil（M/2）-1：
	-  把该节点的值下沉合并

之后删除节点



M阶b+树：

每个节点有最多有M个keys，有M个childrens（和b树不一样）

每个节点至少有floor(M/2)+1个keys，（因为必包含父节点）

叶子节点包含了所有的节点，且有指针指向下一个链表，支持顺序查找





海量数据（字符串在海量数据中匹配）查询，去重：

应用场景：

- word，检查单词拼写错误，比如从海量词典里匹配单词
- 网络爬虫，去重，如何避免爬到相同的url
- 垃圾邮件短信过滤算法
- 缓存穿透



缓存穿透：

使用redis作为缓存减少server对mysql的访问压力

此时redis和mysql都没有某个数据，若黑客利用这一点反复访问，不断地经历访问redis到访问mysql的步骤，系统就会瘫痪。

解决方案：

- 在redis设置key null键值对，只存储key，来过滤对mysql的访问，缺点是占内存，可以设置个key过期失效
- 在server端设置布隆过滤器，



unordered_map/set

利用hashtable: 将字符串映射到int64（常用），并和存储的bucketcount取模得到最终的下标index

hash函数特点：

1.计算速度快

2.hash相似的字符串可以保持强随机分布性

- murmurhash2
- siphash redis 6.0使用

测试地址： https://github.com/aappleby/smhasher  

load factor 负载因子 =  elenum/bucket count，一般>0.5就应该rehash了



解决hash冲突

- 链表法：简单易用，但是容易导致链表过长的极端情况，解决方案是设置一个阈值，比如256，如果链表长度超过256就使用红黑树来存储。
- 开放寻址法：不使用额外空间，如果有冲突就在其它空的地方尝试，可以定义一个步长 

​	i+1 i+2 i+3 i+4....

​	i-1^2,  i+2^2, i- 3^2, i+4^2.....

​	但是会导致同类hash聚集，也就是近似值的hash也近似



解决同类聚集

- 双重哈希：hash = hash1+k*hash2:
- 利用互为质数关系具有传递性，每次移动一个素数位置来减少hash碰撞



 不论是set还是map还是unorderedset/map都需要空间存所有的key，如果是海量数据server的内存应该是放不下的

布隆过滤器：

概率性的数据结构，实现高效插入和查询，能知道某个key一定不存在 或者 可能存在。

优点是更高效，不占空间，缺点是结果是概率性的，存在误差，不支持删除



实现：位图+n个hash （位图就是）

当元素加入位图的时候，通过k个hash值映射到位图的k个位置上， 并置1，当检索的时候，判断k个位置是否都为1，如果有一个不为1，则认为元素不存在，反之如果全部为1，则可能存在（因为某个位置的1可能是被其它hash置1的）。

由于只有0和1，每个位图都被多个元素映射，所以删除会连带影响其他元素，不支持删除元素操作，



四个参数：

- n ：布隆过滤器准备存的元素
- p：能接受的误判率，假阳率
- m：位图的内存大小
- k: hash函数的个数



怎么模拟k个hash函数(不需要真的k个hash)

利用双重hash生成k个hash

hash = (hash1+i*hash2) %m    i∈0~k-1









 

