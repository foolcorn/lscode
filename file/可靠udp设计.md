设计应用层的可靠udp传输



首先研究内核的协议栈

网卡数据进

sk_buffer

copy进协议栈

在copy到用户态



两次copy，开销比较大

零拷贝技术

网卡mmap到内存里。底层是dma（cpu不干预，相当于不消耗资源，不算copy）

应用层可以直接获取。



从网卡中取完整的数据

raw socket

netmap

dpdk



负载均衡

nginx：应用层

haproxy：传输层

lvs：网络层

f5：数据链路层。



优点：完全异步，减少内核拷贝

需要解决 

分片问题

底层数据包内存对齐的问题

应用层实现滑动窗口，进行发送速度的控制。

应用层需要实现epoll多路复用。

要自己实现底层协议

arp

icmp





udp的可靠传输

- ack机制
- 重传机制
- 序号机制
- 重排机制
- 窗口机制



udp是面向报文的



适用于实时应用，比如ip电话，视频会议，直播等。

游戏行业，物联网行业



浪费10%的带宽，换30%左右的传输速度。

一些设计：RTO的1.5X提升，不像tcp是2倍

使用选择性重传和快速重传。



收到的ack不会恒等于丢包的那个ack，而是继续往下递增，这样可以知道丢失的数据包



TCP是会延迟发送的，即便设置nodelay都没用，一样会延迟发送。这样导致RTT较大，从而导致RTO也很大。



una和ack+una



tcp其实是una机制，只显示了此编号前的数据都已经收到，如果要知道此编号后的包是否收到，就必须用sack机制，在option里面缓存一个累积队列。

ack则是显示最高收到的包是哪些。



窗口机制：发送窗口由发送缓存大小，对端接收窗口大小，丢包退让，慢启动（网络拥塞控制）决定。

如果是视频之类的传送，就放弃丢包退让和慢启动。



streamid：唯一标识一个连接

标志位：sign：ack，getsize，providesize

分片标志位：offset

窗口大小windowsize

ts：时间序列号：感觉没啥用

sn：序列号，和tcp的序列号一个作用

recv：已经收到的数据包

una：下一个期望收到的数据包

len：数据长度

data：





google的quic的问题是太臃肿，报头太大



![image-20220809222236486](C:\Users\37412\AppData\Roaming\Typora\typora-user-images\image-20220809222236486.png)



stream的状态机

应用层报文，-》帧封装成stream，stream的分片成帧，送入中枢，发送数据，发送过程中涉及到拥塞控制，主要就是一个慢启动，还有慢启动门限，拥塞发生的这么一个算法。

最后才落到实处把帧等装成packet，然后发送udp packet。

收到udp packet之后，我们解析packet，然后处理帧，根据ack去做流量控制和拥塞控制。

然后把有序帧重组成stream，上交给应用层报文解析









