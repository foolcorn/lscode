### OLTP

联机事务处理。（大部分）



### OLAP

后台做数据分析



### SQL包括

DOL：查询语言，select

DML：插入，更新，删除

DDL：数据定义语言，创表，修改表，删除表

DCL：数据控制语言：授权，收回用户权限

TCL：事务控制语言：commit rollback



mysql架构：

- 不同语言的协议接口。

- mysql的连接池，使用的是select io多路复用来处理连接。（为什么不用epoll，因为连接数不多，且基本都是活跃fd，而且select跨平台）

accept到新连接，就开一个线程去处理。

每个线程，都循环使用阻塞read，等拿到数据再执行命令，当然也包括权限验证的过程。



- 连接池：使用select+阻塞io
- sql接口，语法树
- 进行权限过滤
- 优化器，执行计划
- 缓存组件，lru：利用率很低，后续就取消了
- 存储引擎：innodb
- 文件系统



### 数据库范式

一范式：主键不可分解

二范式：每个字段都依赖于主键，而不是（组合索引主键）的其中一部分

三范式：每个字段都和主键直接相关，而不是间接相关



### CURD

执行过程

连接器，分析器，查询缓存，如果命中直接返回，否则传入优化器，之后是执行器，这里是server层

之后是引擎层，写undolog，存储回滚段指针和事务id，记录目标页在内存中。

根据索引找到数据，返回或者更新，将事务写入到redo log



is null、is not null:判空

不等于<>

#### like：模糊查询

#### 分页查询

比如排行榜，使用orderby，使用 limit a,b，从第a条开始现实b条。



聚合查询：sum avg max min count



group_concat()：分组查询的时候，如果group by的字段和其他字段是一对多（行）的关系，使用concat则可以把多个行的数据连接在一起。

- concat内部连接的时候，可以使用distinct去重后再连接

distinct

order by



### 连表查询

内连接：只保留两张表有对应记录的关系

左链接：保留左表没有对应关系的数据

右连接：保留右表没有对应关系的数据164

外连接：保留所有记录，哪怕没有对应关系



### 子查询



### REGEXP

正则表达式 



### 视图

可以复用，减少重复查询语句的书写

重构利器，因为某种需求，需要将一个表拆成两个表

逻辑更清晰，屏蔽查询细节

权限控制，真实表对用户屏蔽，而是提供一个视图，这样没有dml的权利，但是有dol的权限



### 流程控制

#### 分支

if condition then

....

elseif condition then

...

else

....

end if



case value

​		when value then....

​		when value then...

​		else ...

end case



#### 循环

while condition do

...

end while;



#### LEAVE

leave label 类似break的作用。



### 触发器

 监视对象：table，

监视事件（DML）：insert update delete

触发时间：before after

主要就是针对某个表的dml操作进行一些编程。



### 存储过程

为了完成特定功能的sql语句，存在数据库

能完成比较复杂的判断和运算，有程序逻辑，可复用，执行速度相对快



### 游标

cursor



### 索引

- 主键索引：唯一，不能为null  primarykey
- 唯一索引：和主键的区别在于可以为null   unique
- 普通索引:  允许相同的索引内容，不用唯一   
- 组合索引：多个列的组合索引，key也不用唯一，可以放在红黑树的右子树
- 全文索引，match和against





### b+树

mysql默认大小一页16k

b+树，每个非叶子结点有个数组（有序）

可以通过二分法快速查找。

每个叶子结点都是双向链表。



innodb：聚集索引，数据和索引都在节点

myisam则是索引+数据指针



### INNODB

表是组织索引表，每张表有且仅有一个主键

主键选择：如果没有显式设置，则会选择第一个非空的unique索引作为主键

如果没有非空唯一索引，则会自动生成一个6字节的rowid作为主键

myisam引擎不支持外键，只起注释作用，但是innodb完整支持外键

innodb支持，unique，not null ，default，primarykey， foreiginkey约束

数据和索引都存在idb中

共享表空间，存储共享内容

innodb由段，区，页构成，每个区1mb，有64个页

段：

- 数据段
- 索引段
- 回滚段

区：大小1mb，一个区由64个连续页组成（为了保证连续，一般引擎一次申请4-5个区）

一个页默认为16k



 ### myisam

myd数据使用堆表存储数据

读取性能比较高

myi

myd





### 约束和索引的区别

约束是逻辑概念

索引除了逻辑概念，还有物理存储结构，目前来说，简单粗暴理解，索引就是b+树



数据库的存储结构，

表结构是frm文件存储





#### 聚集索引

以主键构造的b+树，叶子结点中存放数据页，所有数据



#### 辅助索引

不是主键构造的b+树，不包含行记录的所有数据，一般是根据辅助索引映射到主键值，然后再用聚集索引来找整行的数据。



#### 覆盖索引

直接通过辅助索引获得数据，不需要通过聚集索引来找



#### 组合索引

符合最左匹配原则，

查询组合索引的次序可以不同，因为优化器会优化

但是不能中间缺省

某个字段既有单字段索引又有组合索引，优化器会选择组合索引

可以使用explain来看优化器使用的是什么索引



#### 不走索引

查询字段有一个不是索引字段，或者使用key!= num做条件判断的，但是可以调整，使用key<num or key \> num来代替

或者字段参与运算的，发生隐式转换的。

使用like模糊查询。

组合索引，没用第一索引索引，索引失效



#### 索引原则

选择查询数据频次高的，

重复性不高的

短索引：加快io时间



### 事务

由多个sql语句组成，目的是将数据库从一种一致性状态转换为另一种一致性状态

可以在事务中设置保存点，利用undolog rollback到指定的保存点



#### acid特性

原子性：atom：要么都做commit，要么都不做，全部rollback

隔离性：isolate：每个读写事务对象和其它事务的对象能相互分离，两种方法：解决一致性非锁定读（MVCC：多版本并发控制），类似mesi机制，或者加锁

持久性：d，提交后，dml操作会持久化，写入到redolog磁盘文件，比写入到b+树要快（记录的是物理日志，写到哪一页，页偏移值，具体数据），即便发生宕机，也能恢复

如果事务执行后，写redolog的时候崩了，则该事务会消失，但是mysql是高可靠性的数据库，而不是高可用性数据库，高可用性可以通过集群来实现。

一致性：consistency，从一种状态变成另一种状态



#### 并发异常

脏读：一个事务读到另一个事务没有提交的事务。

不可重复读：一个事务先读了一个数据，此时另一个事务提交了该数据，原事务再次读这个数据，就会使数据前后不一致。

幻影读：一个事务读的一个数据，根据这个数据进行的业务，修改，或者插入出现了错误，因为期间该数据可能会被其它事务给修改。



#### 隔离级别

不管哪种隔离级别，在进行写操作的时候，都会加锁，但是对于读则有不同的方案。



read uncommitted：读未提交，读不加锁。

read committed：读已提交，利用mvcc，读取历史快照数据

repeatable read：可重复读，支持mvcc，读取事务开始时的版本数据

serializable：可串行化：该界别给读加共享锁，所有事务串行执行，隔离界别最严格



### 主从复制

binlog：事务提交后产生

从数据库读取binlog，写入到库本地的relay log中继日志

从库读取中继日志，通过replay重新执行一遍。



事务commit，先写到redolog，再写到binlog   myisam没有日志文件

慢查询日志



### 读写分离

写主库

读从库





