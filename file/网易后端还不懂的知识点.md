#### 虚表的内存分布：

每个类的虚拟表是在编译的时候就生成的，然后在运行时定义一个对象时编译器会扩张构造函数，生成一个vptr指向该虚表。其大小为32个字节或者64个字节，位置在类的最前面，所以可以将类指针转成long类型指针解引用来获取vptr的值。

并通过vptr可以找到虚拟表，虚拟表可以看成是一个数组，是通过偏移量（offset）或者说数组下标确定你要找的是哪个方法，并映射数组到函数指针。

多重继承的时候，如果D继承了ABC三个父类，则编译阶段会给D生成三个基表ABC，且D自身和ABC不重合的virtual函数会添加在A表中，BC表无，

所以只能通过A\*或者D\*来访问D的虚拟成员。

如果D覆盖了父类的方法，则会在ABC三个表都覆盖同名的virtual方法。



#### 菱形继承和虚继承

多重继承的时候，BC继承了A，D又继承了BC，这个时候就会产生A的冗余，也就是A的成员会在D中重复出现

解决方法就是虚继承，如果使用虚继承，会把A的成员放在类的最下面，然后通过B表和C表存一个头指针到该A成员的偏移量，A，B表中偏移量不同。



#### socket补充

- socket：AF_LOCAL, AF_INET
- bind:  sin_family=AFINET, sin_port=htons(xxxx), sin_addr.s_addr = INADDR_ANY
- listen: backlog
- accept
- close



#### IP层补充

私有地址是用在局域网上的，在广域网上不使用

A类地址，第一段为10

10.0.0.1-10.255.255.254

10.0.0.0是整个网段，10.255.255.255是广播地址

B类地址，以172.16-172.31开头的都是私网地址

172.16.0.1-172.31.255.254

C类地址，192.168.0.1-192.168.255.254



#### dpdk

走内核协议栈的缺点：

- 如果有大量数据到来，会导致触发大量中断
- 包要从网卡拷贝到内核（ring buffer），再经过系统调用，从内核拷贝到用户态
- 如果不走tcp/ip,也用不到用户态协议栈。
- 解决了netmap框架的小缺陷，netmap框架虽然可以实现零拷贝，但是操作系统调度导致的缓存失效会影响性能

dpdk的灵魂有两个方面，一个是内核级的驱动，一个是用户层的轮询

dpdk重载了网卡驱动，通过内核旁路协议绕过linux内核协议栈，通过零拷贝dma写入到共享内存。

主要是uio的机制，igb uio模块，截获网卡产生的终端，并且重设中断回调的行为，从而绕过内核协议栈，且igbuio会在内核初始化的时候，将网卡的硬件寄存器映射到用户态。

用户态使用轮询代替中断

在dpdk新版本使用轮询还是中断是动态变换的



#### 谷歌BBR：

慢启动，拥塞避免，快速重传，快速恢复这几个算法其实已经过时了，毕竟现在网络环境和80年代低带宽，浅缓存队列的情况完全不一样了。

- 及时速率的计算，计算即时带宽，该带宽是bbr一切计算的基准，bbr将会根据当前的即时带宽以及所处的pipe状态了计算pacing rate和窗口大小。
- RTT的跟踪：怎么计算bbr的带宽利用率，需要探测到带宽最大值和rtt的最小值，这样计算出的bdp（带宽时延积）是最大容量，BBR目的就是达到这样的效果，所以会持续跟踪计算RTT。
- BBR状态机：bbt不再跟踪系统的tcp状态机，而是用自己的指标来计算bw和rtt，不管tcp丢包还是什么状态。
  - startup：
  - drain：
  - probe bw：带宽
  - probe rtt：rtt
- 两个指标：窗口+发包速率：以前的算法单纯就是框定一个窗口，却没有一个机制来决定一堆数据包以怎样的速率和时间间隔发送出去。



##### 带宽计算：

两个参数，1.应答了多少数据d，2.应答这么多数据用的时间t

则带宽bw = d/t,

bbr不在意应答报文的类型，是普通的ack，还是超时重传的sack也好，总之都会极端。











